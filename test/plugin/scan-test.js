'use strict';

const tape = require('tape');
const common = require('../common');
const versionMark = common.versionMark;

tape('v8 findrefs and friends', (t) => {
  t.timeoutAfter(common.saveCoreTimeout);

  // Use prepared core and executable to test
  if (process.env.LLNODE_CORE && process.env.LLNODE_NODE_EXE) {
    test(process.env.LLNODE_NODE_EXE, process.env.LLNODE_CORE, t);
  } else {
    common.saveCore({
      scenario: 'scan-scenario.js'
    }, (err) => {
      t.error(err);
      t.ok(true, 'Saved core');

      test(process.execPath, common.core, t);
    });
  }
});

function testFindrefsForInvalidExpr(t, sess, next) {
  sess.send('v8 findrefs invalid_expr');
  sess.waitError(/error:/, (err, line) => {
    t.error(err);
    t.ok(/^error: error: /.test(line)
        && / use of undeclared identifier 'invalid_expr'$/.test(line),
      'invalid expression should return an error'
    );
    next();
  });
}

function test(executable, core, t) {
  const sess = common.Session.loadCore(executable, core, (err) => {
    t.error(err);
    t.ok(true, 'Loaded core');

    sess.send('v8 findjsobjects');
    // Just a separator
    sess.send('version');
  });

  sess.linesUntil(versionMark, (err, lines) => {
    t.error(err);
    t.ok(/\d+ Class/.test(lines.join('\n')), 'Class should be in findjsobjects');

    sess.send('v8 findjsobjects -d');
    // Just a separator
    sess.send('version');
  });

  sess.linesUntil(versionMark, (err, lines) => {
    t.error(err);
    t.ok(/3 +0 Class: x, y, hashmap/.test(lines.join('\n')),
         '"Class: x, y, hashmap" should be in findjsobjects -d');

    sess.send('v8 findjsinstances Class_B')
    // Just a separator
    sess.send('version');
  });

  sess.linesUntil(versionMark, (err, lines) => {
    t.error(err);

    t.ok((lines.join('\n').match(/<Object: Class_B>/g)).length == 10, 'Should show 10 instances');
    t.ok(/\(Showing 1 to 10 of 10 instances\)/.test(lines.join('\n')), 'Should show 1 to 10 ');

    sess.send('v8 findjsinstances -n 5 Class_B');
    sess.send('version');
  });

  sess.linesUntil(versionMark, (err, lines) => {
    t.error(err);

    t.ok((lines.join('\n').match(/<Object: Class_B>/g)).length == 5, 'Should show 5 instances');
    t.ok(/\.\.\.\.\.\.\.\.\.\./.test(lines.join('\n')), 'Should show that more instances are available');
    t.ok(/\(Showing 1 to 5 of 10 instances\)/.test(lines.join('\n')), 'Should show 1 to 5 ');

    sess.send('v8 findjsinstances -n 5 Class_B');
    sess.send('version');
  });

  sess.linesUntil(versionMark, (err, lines) => {
    t.error(err);

    t.ok((lines.join('\n').match(/<Object: Class_B>/g)).length == 5, 'Should show 5 instances');
    t.notOk(/\.\.\.\.\.\.\.\.\.\./.test(lines.join('\n')), 'Should not show ellipses');
    t.ok(/\(Showing 6 to 10 of 10 instances\)/.test(lines.join('\n')), 'Should show 6 to 10 ');

    sess.send('v8 findjsinstances Class_B');
    sess.send('version');
  });

  // Test for recursive findrefs, a new `Class_C` was introduced in `inspect-scenario.js`
  sess.linesUntil(versionMark, (err, lines) => {
    t.error(err);

    for (let i=0; i < lines.length; i++) {
      const match = lines[i].match(/(0x[0-9a-f]+):<Object: Class_B>/i);
      if (match) {
        sess.send(`v8 findrefs -r ${match[1]}`);
        break;
      }
    }
    sess.send('version');
  });

  // Test if parent `Class_C` is present on tree generated by previous command
  // This means that we successfully transversed the reference tree
  sess.linesUntil(versionMark, (err, lines) => {
    t.error(err);
    t.ok(/Class_C\.arr/.test(lines.join('\n')), 'Should find parent reference' );
    sess.send('v8 findrefs -n my_class_c');
    sess.send('version');
  });

  // Test for findrefs -n
  sess.linesUntil(versionMark, (err, lines) => {
    t.error(err);
    t.ok(/(0x[0-9a-f]+): Class_C\.my_class_c=(0x[0-9a-f]+)/.test(lines.join('\n')), 'Should find class C with property');
    sess.send('v8 findrefs -r -n my_class_b');
    sess.send('version');
  });

  // Test for -r -n
  sess.linesUntil(versionMark, (err, lines) => {
    t.error(err);
    t.ok(/Class_C\.arr/.test(lines.join('\n')), 'Should find parent reference with -r -n' );
    // TODO(mmarchini) see comment below
    // sess.send('v8 findrefs -s "My Class C"');
    sess.send('v8 findjsinstances Zlib');
    sess.send('version');
  });

  /* TODO(mmarchini) we need to fix
   * https://github.com/nodejs/llnode/issues/267 before re-enabling this test
  // Test for findrefs -s
  sess.linesUntil(versionMark, (err, lines) => {
    t.error(err);
    t.ok(/(0x[0-9a-f]+): Class_C\.my_class_c=(0x[0-9a-f]+)/.test(lines.join('\n')), 'Should find class C with string');
    sess.send('v8 findrefs -r -s "Class B"');
    sess.send('version');
  });

  // Test for -r -s
  sess.linesUntil(versionMark, (err, lines) => {
    t.error(err);
    t.ok(/Class_C\.arr/.test(lines.join('\n')), 'Should find parent reference with -r -s' );
    sess.send('v8 findjsinstances Zlib');
    sess.send('version');
  });
  */

  sess.linesUntil(versionMark, (err, lines) => {
    t.error(err);
    // Find refs to every Zlib instance
    let found = false;
    for (let i = lines.length - 1; i >= 0; i--) {
      const match = lines[i].match(/(0x[0-9a-f]+):<Object: Zlib>/i);
      if (!match)
        continue;

      found = true;
      sess.send(`v8 findrefs ${match[1]}`);
    }
    t.ok(found, 'Zlib should be in findjsinstances');
    // Just a separator
    sess.send('version');
  });

  sess.linesUntil(versionMark, (err, lines) => {
    t.error(err);

    // `class Deflate extends Zlib` makes instances show up as
    // Transform objects (which Zlib inherits from) in node.js 8.0.0.
    // That change was reverted in https://github.com/nodejs/node/pull/13374
    // and released in 8.1.0.
    const re =
        (process.version === 'v8.0.0' ?
            /Transform\._handle/ : /Deflate\._handle/);
    t.ok(re.test(lines.join('\n')), 'Should find reference');
    t.ok(/Object\.holder/.test(lines.join('\n')), 'Should find reference #2');
    t.ok(/\(Array\)\[1\]/.test(lines.join('\n')), 'Should find reference #3');

    // Test if LastContextType constat exists
    sess.hasSymbol('v8dbg_LastContextType', (err, hasSymbol) => {
      t.error(err)
      if(hasSymbol)
        t.ok(/Context\.scopedAPI/.test(lines.join('\n')), 'Should find reference #4');

      // `waitError()` don't share the same `waitQueue` with `wait()` so that
      // we add the function below to delay the event registration.
      testFindrefsForInvalidExpr(t, sess, () => {
        sess.quit();
        t.end();
      });
    });
  });
}
